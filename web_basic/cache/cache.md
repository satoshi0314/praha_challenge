# cache

[課題](hhttps://airtable.com/tblg8ePOEQRDtIGiY/viwV3pAlEvPOOgmHF/recLu5JYLtVoU3uk0?blocks=hide)

## 課題 1

### なぜキャッシュが必要か
  ウェブキャッシュは遅延やネットワークのトラフィックを削減して、リソースを表示するために必要な時間も短縮するため、アプリケーションの高速化に不可欠なため。

### キャッシュの種類
  - ブラウザキャッシュ
    1人のユーザーのためのキャッシュで、ユーザーがHTTPでダウンロードしたすべてのドキュメントを保持します。このキャッシュは訪問済みのドキュメントで、サーバーとのやりとりを追加で行うことなく戻る/進む操作、ページの保存、ソースの表示をできるようにします。またキャッシュ済みのコンテンツをオフラインで表示できるようにもします。
  - プロキシキャッシュ
    複数のユーザーによって再使用されるレスポンスを保存するキャッシュで、人気があるリソースを何度も再使用してネットワークのトラフィックや遅延を低減させることができます

### ブラウザがキャッシュを制御するために存在するヘッダー
  - Cache-Control
    - リクエストおよびレスポンスでキャッシュ機能に関するディレクティブを指定するために使用します。
      - 具体的には、リソースの有効期限や再検証を設定する
  - Pragma
    - HTTP/1.0 クライアントとの後方互換用のもので、`Cache-Control: no-cache` と同じ働きをする。
    - Cache-Control ヘッダーがある場合は無視される
  - Expires
    - レスポンスが古くなると見なされる日時が入ります
    - その値から Date ヘッダーの値を減算した結果を鮮度の寿命にします
    - レスポンスに max-age または s-maxage ディレクティブを持つ Cache-Control ヘッダーがある場合、Expires ヘッダーは無視されます。
  - ETag
    - ETag ヘッダーがリソースのレスポンスの一部に含まれていたら、クライアントは以降のリクエストでキャッシュ済みリソースの確認を行うために If-None-Match をヘッダーに含めることができます。
  - Last-Modified
    - Cache-Control, Expiresのどちらも与えられていないときに、Date ヘッダーの値から Last-modified ヘッダーの値を減算して 10 で割った結果をキャッシュの寿命にします
  - Vary
    - 提供元のサーバーからレスポンスを得るように要求せずにキャッシュ済みのレスポンスを使用できるかを判断するために、以降のリクエストヘッダーをどのように照合するかを定義します。
    - Vary ヘッダーフィールドを持つキャッシュ済みレスポンスに合致可能なリクエストをキャッシュが受け取ったとき、Vary ヘッダーで指定されたすべてのヘッダーフィールドが元の (キャッシュ済み) リクエストと新たなリクエストの両方で一致しなければ、キャッシュ済みレスポンスを使用してはいけません

### ブラウザのキャッシュサイズの上限
  - キャッシュサイズの容量上限を超えると何が起きるでしょうか？
    - 上限に達すると origin eviction と呼ばれる処理を実行して、ストレージの総量が再び上限を下回るまで、生成元全体に相当するデータを削除します。
  - 容量上限はどの程度でしょうか？
    - ブラウザーのストレージの最大容量は動的であり、ハードディスクドライブのサイズに応じて変わります。グローバルリミットはディスクの空き量量の 50% に決められます。
    - また、グループリミットというもうひとつの制限もあります。これは、グローバルリミットの 20% として定義されます。それぞれの生成元は、グループ (生成元のグループ) の一部です。グループは、eTLD+1 ドメインごとに 1 つ作られます。
> https://developer.mozilla.org/ja/docs/Web/API/IndexedDB_API/Browser_storage_limits_and_eviction_criteria

### 動的なサイトをキャッシュするなら、expiresは使わない方が良い理由と対策
  - 理由
    - expiresの期日まで変更が反映されないため
  - 対策
    - Etagをレスポンスヘッダーに含め、かつブラウザが以降のリクエストでキャッシュ済みリソースの確認できるように If-None-Match をヘッダーを使用する。
    - Last-Modified と If-Modified-Sinceヘッダーを用いて、最後にリソースが更新された時間を確認してキャッシュを使うようにする。

### 他のサイトのキャッシュ使用例
- MDN(https://developer.mozilla.org/ja/)
  - cache-control: max-age=86400, public
  - etag: W/"61b2e23575c00bb95d87e0471bb57e53"
    - 次回のリクエストヘッダーに含まれる`if-none-match`の値とそのレスポンスのetagに含まれる値が一緒の限りキャッシュが使われる
  - last-modified: Wed, 18 Aug 2021 01:45:59 GMT
    - `if-modified-since`の値がlast-modifiedの値を超えない限りキャッシュが使われる
  - vary: Accept-Encoding
    - レスポンスのエンコーディングの方式が一緒の限りキャッシュが使われる

## 課題３（成果物に関する質問）

### ブラウザキャッシュを使うべきではない状況を考えて、ペアと会話してみてください
  - リソースが頻繁に変わるもの

## 課題４（クイズ）
- Cache-Controlヘッダに`no-store`が設定されていた場合, `no-cache`が設定されていた場合, `must-revalidate`が設定されていた場合の挙動の説明をしてください
- キャッシュの鮮度の寿命は以下の条件の場合どのように計算されるでしょう
  - cache-controlヘッダがない
  - Expiresヘッダは存在する
  - Last-Modifiedヘッダは存在する
